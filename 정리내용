# springBackend
엔터프라이즈 애플리케이션 이란?
기업과 조직의 업무를 처리해 주는 시스템을 말합니다.
많은 사용자의 요청을 동시에 처리해야 하기 때문에 서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야 한다.
그런의미에서 자바는 엔터프라이즈 애플리케이션을 개발하는데 하부 구조를 포괄적으로 제공한다.
스프링이 하부 구조를 처리하여 애플리케이션 개발에 개발자가 집중할 수 있게 해주며
엔터프라이즈 서비스 기능을 POJO에 제공하는 것이다. (쉽게 이야기하면 엔터프라이즈 = 회사, 애플리케이션 = 프로그램 기능이라고 생각하면 된다.)
엔터프라이즈 서비스라고 하는 것은 트랜잭션, 보안, 메일, 메시징, 캐시 와 같은 
엔터프라이즈 애플리케이션(회사 프로그램에) 요구되는 기술들을 이야기 합니다.

# 스프링 핵심 기술
복잡성을 다루기 위한 스프링의 기본 전략은 비즈니스 로직을 담은 애플리케이션의 코드와
엔터프라이즈의 코드를 처리를 분리 시키는 것 입니다.
이것을 POJO라고 한다.
POJO는 2000년, 마틴 파울러가 컨퍼런스 준비 과정에서 만든 용어이다.
객체지향 원리에 충실하며, 특정 규약과 환경에 종속되지 않게 재활용 할수있도록 설계된 방식을 말하며,
자동화된 테스트에 유리하며, 유지보수성이 높다.

# God Object
1개의 파일에 모든 로직을 구현하게 되면 하나의 거대한 클래스가 탄생되며 클래스의 목적을 알수가 없어 진다.
또한 유지보수가 쉽지않아 한가지의 변화로 쉽게 망가질 수 있다.
이를 God object 안티 패턴이라 명칭한다.

# 관심사의 분리 (Separation of Concerns)와 계층화 (layering)
복잡한 소프트웨어를 계층으로 나눔으로써 서로 영향을 주지 않도록 분리하는 것이다.

# 도메인 (Domain)
소프트웨어 개발에서 말하는 도메인은 프로그램이 쓰이는 대상 분야라는 의미이다.

# 소프트웨어 개발시 지켜야 할 두가지 조건
오늘 완셩해야 하는 기능을 구현하는 코드를 짜야하는 동시에
내일 쉽게 변경할 수 있는 코드를 짜야 한다. - Sandi Metz

#추상화
어떤 것들의 공통적인 성격을 뽑아서 이를 따로 분리해내는 작업

#템플릿 메서드 패턴 (디자인 패턴에서)
부모 클래스의 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 구조

#상속은 2가지 관점에서 설계에 안 좋은 영향을 끼친다.
1. 캡술화를 위반
2. 설계가 유연하지 못함.

코드를 재사용하기 위해서는 '상속'보다는 '합성'을 사용하는 것이 좋다. (도서:Effective Java 3rd Edittion - Joshua Bloch)
*합성: 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법.
!추상 클래스보다는 인터페이스를 우선하고 객체는 인터페이스를 사용해 참조하는 것.

인터페이스를 정의된 객체만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있으며, 참조되는 인스턴스를 교체하는 것이 비교적 쉽다.
 

#JAXB(Java Architechture for XML Binding 자바 클래스를 XML로 표현하는 자바 표준 API)의 두 가지 주요 기능
마샬링(Marshalling) : 자바 객체 => XML문서
언마샬링(Unmarshalling) : XML 문서 => 자바 객체


#Junit은 자바용 테스트 프레임워크이다.

#Factory
객체의 생성 방법을 결정하고, 생성한 객체를 반환하는 역할을 수행하는 객체를 보편적으로 Factory라고 부른다.
객체를 생성하는 쪽과 생선된 객체를 사용하는 쪽 역할과 책임을 분리하려는 목적으로 사용.


#제어의 역전 (제어 권한을 자신이 아닌 다른 대상에게 위임)
일반적인 흐름은 메인 메소드에서 프로그램이 시작되는 지점에서 사용할 객체를 결정하고, 결정한 객체를 생성하고, 생성된 메소드를 호출하며 반복되는것이다.

*자바프로그램은 메인 메소드를 제외하고 모든 객체는 제어권한을 위임 받은 객체에 의해 결정되고 만들어 진다.


#SOLID 원칙 (깔끔한 설계를 위해 적용 가능한 5가지 소프트웨어 설계 원칙)
함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이 클래스들을 서로 겹합하는 방법으로 구성
내부의 구조를 이해하기 쉽고, 변경에 유연하게 만드는데 목적을 두고 있다.

1. 개방 폐쇄 원칙 (Open-Closed Principle; OCP) - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
2. 의존성 역전 원칙 (Dependency-inversion Principle; DIP) - 상위 정책은 하위 정책에 의존하면 안된다. 하위 정책이 상위 정책에 정의된 추상 타입에 의존해야 한다.

위 두 원칙은 높은 응집도와 낮은 결합도라는 '관심사의 분리(Separation of Concerns)'와 도 관련이 있다.
관심이 같은 것끼리는 한곳으로 모으고, 다른 것은 따로 떨어뜨려 서로 영향을 주지 않도록 분리하는 것이다.
응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.
결합도가 낮다는 건 하나의 오브젝트가 변경될 때에 관계를 맺고 있는 다른 오브젝트에 영향을 안준다는 뜻이다.


#디자인 패턴(Design Pattern)
자주 발생하는 문제에 대해 검증된 해결책을 제시한다.

!현재 이 프로젝트는 지금까지의 코드로 보아 개방-패쇄 원치고가 의존성 역전 원칙을 따르고, 응집력은 높고, 결합도는 낮은 전략패턴을 적용했다.


#의존 관계 주입 (Dependency Injection) DI
외부에 독립적인 존재가 객체를 생성한 후, 이를 전달해서 의존 관계를 해결하는 방법을 의존 관계 주입이라고 부릅니다.

의존 관계 주입에는 3가지 방법이 있다.
1.생성자 주입 - 객체를 생성하는 시점에 생성자를 통한 의존 관계 해결.
2.설정자 주입 - 객체를 생성한 후, setter 메소드를 통해서 의존 관계를 해결.
3.메소드 주입 - 메소드 실행시 인자를 이횽해서 의존 관계를 해결.

#다형성
객체 지향 프로그램의 코드 시점 의존 관계와 실행 시점 의존 관계가 다를 수 있다는 사실을 기반으로 합니다.
서로 다른 메소드를 실행할 수 있게 합니다.

객체 지향 설계란 의존관계를 관리하는 것이고 객체가 변경을 받아들일 수 있게 의존 관계를 정리하는 기술이라고 할 수 있다.

# 스프링 컨테이너 와 Bean 
스프링에서는 스프링이 제어권을 가지고 직접 생성하고 의존 관계를 주입하는 객체를 빈이라고 한다. 
컨테이너 생성, 관계 설정, 사용들을 제어해주는 제어의 역전 원리가 적용된 객체를 가리키는 말이다.

* 스프링은 IoC 컨테이너인 애플리케이션 콘텍스트나 빈 팩토리로 빈 구성 정보를 읽어 애플리케이션을 구성합니다.

# 스프링 IoC컨테이너 (Spring IoC Container)와 빈(Beans)
컨테이너는 제어의 역전 원리가 적용된 스프링 핵심 컴포넌트다.
컨테이너에 의해 생성 및 조립된 후 관리(초기화, 소명 등)되는 객체를 빈(Beans)이라 부른다.
빈 생성 시 의존관계 주입(Dependency Injection, DI)이 일어난다.
빈 구성정보를 바탕으로 비즈니스 오브젝트를 이용해 애플리케이션 구성하고 생애를 관리한다.

*스프링 IoC 컨테이너의 가장 기초적인 역할은 스프링은 빈 구성 정보를 읽고, 내부적으로 추상화된 객체를 반들어 사용하는 것이다.
스프링은 빈 구성정보를 읽고 내부적으로 Bean Definition이라는 인터페이스로 추상화된 객체를 만들어 사용합니다.
! 빈 구성정보는 특정한 파일 포맷이나 형식에 제한되거나 종속되지 않습니다.

# 빈 구성정보(Configuration Metadata)란?
스프링 컨테이너가 빈 객체가 생성 및 구성, 조립시 사용하는 설정 정보다.
컨테이너 기능을 설정하거나 조정이 필요할 때도 사용된다.
자바, 코틀린, 그루비(Groovy), XML등 다양한 방식으로 작성할 수 있다. 

! 스프링 3.1 이하로 작성된 스프링 애플리케이션은 주로 XML형식으로 빈 구성 정보를 작성했으나, 최근에는 자바 코드로 빈 구성 정보를 작성하는 경우가 훨씬 많다.
스프링 부트를 사용하게 되면 특별한 경우가 아니고서는 자바 코드로 빈 구성 정보를 작성하는 것을 권하고 있다.

 # 스프링의 빈 스코프
 스프링 컨테이너는 빈을 생성할때 단 하나의 빈을 만들지, 아니면 빈이 요철될 때마다 새로운 빈 객체를 생성할지 결정하는 메커니즘을 가지고 있습니다.
 이 메커니즘을 '빈 스코프'라고 한다.
 
 단 하나의 빈 객체만 만들 때에는 싱글톤 스코프라고 부르며, 빈이 요청될 때마다 새로운 빈을 생성하는 것을 프로토타입 스코프라고 부른다.
 *빈을 설정할때 별도로 설정해 주지 않으면, 기본적으로 싱글톤 스코프가 지정된다.
 
 # 싱글톤 스코프
 모든 빈의 기본 스코프로, 스프링 컨테이너가 시작될때 생성되고, 스프링 컨테이너가 종료될 때 소멸됩니다.
 싱글톤 스코프 빈은 스프링 컨테이너 내에서 단 하나만 생성되고, 그 빈을 의존하는 모든 빈에 유일한 객체를 공유합니다.
 
 # 프로토타입 스코프
 스프링 컨테이너가 빈을 요청받을 때마다 항상 새로운 빈을 생성해서 반환하도록 동작한다.
 
 자바 코드로 작성하는 빈 구성 정보는 관심사가 같은 컴포넌트들을 함께 묶어 모듈화가 가능합니다. 
 여러개의 빈 구성 정보를 적성하여 조합을 할 수 있다.
 
 
 * 스프링은 컨테이너에 빈을 자동으로 등록해 주는 기능을 제공합니다.
 이 기능은 ComponentScan 애노테이션을 통해 활성화를 할 수 있다.
 
@ComponentScan을 설정하고 지정된 패키지 경로에서 @Component 애노테이션과 같이 스테레오타입으로 선언된 클래스를 찾아 빈으로 등록하고 관리합니다.
패키지를 지정하지 않으면, ComponentScan 애노테이션이 선언된 클래스를 기준으로 탐색한다고 생각하면 된다.

스테레오 타입의 애노테이션을 몇가지 종류가 더 있다.
대표적으로
1.Component
2.Controller
3.Service
위의 3가지 애노테이션은 빈을 정의하는데 사용된다.

* 스프링은 빈이 생성된 후 자동으로 의존 관계를 주입해 주는 자동 와이어링 기법을 제공한다.

* 자동으로 의존 관계 주입을 해 주는 기능은 기본적으로 선언되어 있는 타입을 기반으로 의존 관계 주입 대상을 해결합니다.

스프링 컨테이너는 기본적으로 컨테이너에 등록이 될 때, 이름을 가지고 등록이 된다.
!본인이 직접 등록 할때는 메소드의 이름이 빈의 이름이 되어서 등록이 되지만, ComponentScan을 통해서 자동으로 빈이 등록이 될 때는 클래스의 이름을 기반으로 해서
빈의 이름이 적절한 이름으로 등록이 되게 되는데 기본적으로 클래스의 첫 번째 대문자가 소문자가 되고 나머지는 풀네임을 써서 등록이 된다.

#스프링의 Testing 기능
테스트는 스프링의 포조과 의존관계 주입을 이용한 프로그래밍 모델이 제공하는 기능 중 하나이다.
포조 프로그래밍은 테스트를 손쉽게 작성할 수 있는 환경을 제공해 주고 기술에 종속되지 않는
코드를 작성할 수 있게 해 줍니다.

테스트를 위해 서버에 배치 하거나 테스트 서버에 연결하지 않아도 스프링 컨테이너 만으로
이상적인 통합 테스트가 가능합니다.

스프링 테스트는 컨테이너를 생성 및 관리하고 테스트에 적용해주는 기능을 가진 프레임워크입니다.
이를 테스트 컨텍스트 프레임워크라 부릅니다.

테스트 컨텍스트 프레임워크는 JUnit과 TestNG와 같은 자바용 테스트 프레임워크와 잘 통합되어 있어
실 운영환경과 유사한 구성의 통합 테스트를 손쉽게 만들 수 있다.

# 엔터프라이즈 애플리케이션의 계층
프리젠테이션(Presentation): 사용자와 소프트웨어간 상호작용을 처리한다. ->
도메인(Domain): 핵심 업무 논리를 처리하는 객체들로 구성되며 엔터프라이즈 애플리케이션에서 가장 중요한 자산이다. -> 
데이터 원본(DataSource): 파일 또는 데이터베이스 시스템 등과 데이터 송/수신을 처리한다.
또 다른 말로는 퍼시스턴스(Persistence) 계층이라고도 한다.

*소프트웨어를 계층으로 나누고 분리시키는 건 서로 변경의 주기가 다르고 또 다른 맥락에서는 구체적인 세부 기술로부터 도메인 논리를 보호하기 위함도 있습니다.
도메인 계층은 핵심 업무 논리 외에는 없는 것이 가장 좋습니다.

# 인터페이스 소유권을 역전시킨 객체지향적인 모듈 구조

추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시키는 기법을 분리된 인터페이스 패턴(Separated Interface Pattern)이라 한다.
! 의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전을 시켜야 한다.

좋은 객체 지향 설계를 위해서는 의존성을 역전시켜야 합니다.

# 소프트웨어의 두 가지 가치
행위적 가치: 사용자가 가진 문제를 해결해주는 것
구조적 가치: 변경하기 쉬운 소프트웨어를 만드는 것

# 소프트웨어를 구성하는 두 가지 요소
정책: 모든 업무 규칙과 업무 절차를 구체화 한 것
구현 세부사항: 입출력 장치, 데이터베이스 등 시스템을 사용 또는 구동하는데 필요한 것

애플리케이션의 핵심을 외부의 기술적인 부분들과 분리시키는 것이 핵심이다.(분리된 영역은 테스트하기 쉽고, 어렵지 않게 변경하기 쉽습니다.)
반드시 지켜야 하는 원칙은 외부에서 내부로 접근하는 의존 방향입니다.

# 객체지향에서 가장 중요한 것
애플리케이션의 기능을 구현하기 위해서 협력에 참여하는 객체들 사이의 상호 작용을 해야 한다.
협력에 참여하기 위해 역할을 부여받고 역할에 적합한 책임을 수행합니다.

# 스프링의 프로파일 기능(환경에 따른 빈 구성 기능을 제공)
개발 서버와 QA 서버 또는 프로덱션 서버에서 사용하는 데이터 소스의 유형이 다를때,
성능 검증 서버에서 배포 시에만 모니터링 인프라를 활성화시킬때,
고객별로 사용자화된 애플리케이션을 제공할 때,


# 스프링 5.0부터는 스프링 JCL 모듈을 통해 로깅 프레임워크인 SLF4 API와 Log4J 2.0 API를 지원하고 있습니다.
SLF4J는 (Simple Logging Facade for Java의 첫글자를 따서) 파사드 패턴을 이용한 로깅 프레임워크 이다. 
추상 로깅 프레임워크이기 때문에 단독으로는 로깅을 할 수가 없습니다. 

애플리케이션에 SLF4J와 API와 Logback 의존성을 추가해야 한다.

# 서비스 추상화로 스프링 OXM 모듈을 제공
자바 객체와 XM을 매핑해서 상호 변환해 주는 기술을 Object-XML Mapping이라 부르고, OXM이라고도 한다.
현재 지원하는 OXM기술은 JAXB, 그 외에도 JIBX, XStream이 있습니다.

자바 객체를 XML로 변환해 주는 Marshaller와 반대로 XML을 자바 객체로 변환하는 Unmarshaller가 있습니다.


# 이식 가능한 서비스 추상화(Portable Service Abstraction)

환경과 구현 기술의 변경과 무관하게 일관된 방식으로 기술을 다룰 수 있게 지원한다.
엔터프라이즈 애플리케이션에 사용되는 다양한 기술의 서비스 추상화가 제공된다.
제어의 역전(IOC) 원리를 통해 POJO에게 제공된다.


# 빈 생명 주기의 확장 지점

스프링 컨테이너는 빈의 생성부처 초기화, 소멸에 이르는 생명 주기에 관여 할 수 있는 확장 지점을 제공하고 있습니다.
대표적인 콜백 인터페이스 InitializingBean 과 DisposableBean 이라고 하는 인터페이스 이다.
객체가 소멸될떄 네트워크 연결 해제 등의 리소스 정리가 필요하다면 DisposableBean을 활용할 수 있다.

자바 플랫폼에서 JSR 250 자바 표준 애노테이션으로 빈 생명 주기에 관여 할 수 있다.
빈 등록시 초기화 또는 소멸시 사용될 메서드를 등록 할 수 있다.

# 런타임 환경 서비스 추상화인 Environment 인터페이스를 제공하고 있습니다.
스프링은 이런 외부 설정 파일이나, 시스템 환경 변수나 그 외에도 다양한 방식으로부터 일관된 방식으로 환경 정보를 읽을 수 있는
런타임 환경 서비스 추상화인 Environment 인터페이스를 제공하고 있습니다.

# 스프링은 @Value 애노테이션을 이용해 빈 프로퍼티 값 설정을 지원합니다.

# 환경 추상화(Environment Abstraction)란?

실행 환경에 따른 빈 구성을 할 수 있고, 일관된 방식으로 외부 설정정보를 관리하고, 접근한다.
프로파일과 프로퍼티 소스로 구성되며, 컨테이너와 통합 된 서비스 추상화이다.

# 빈 정의 프로파일(profiles)로 환경에 따라 컨테이너 구성하기

빈 정의 프로파일은 실행 환경에 따라 컨테이너에 빈을 등록할 수 있는 매커니즘이다.
@Profile 애노테이션으로 프로파일 별로 빈 등록을 할 수 있다.
프로파일은 OS 환경변수, JVM 시스템 파라메터, Environment API 등을 통해 활성화할 수 있다.
보편적으로 환경은 개발, 운영 또는 성능 측정 등 애플리케이션이 실행되는 환경을 뜻한다.

ex) @Profile("development") development 프로파일이 활성화되면 메모리 기반의 데이터 소스를 사용하며, 

@Profile("production") production 프로파일이 활성화되면 Jndi를 통해 데이터 소스를 조회합니다.

프로파일 활성화는 Environment API를 이용한 프로그래밍 방식이나 OS 환경변수로 활성화, JVM System Parameter, 서블릿 배포서술자(web.xml)로 활성화 설정 정보를 이용하는 방식을 지원합니다.

프로퍼티는 키=밸류 형식으로 작성된 설정 정보로 보편적으로 애플리케이션 외부에서 불러 구성한다. (다양한 소스를 일관된 방식으로 사용할 수 있게 해주는 서비스 추상화이다.)
환경변수, 서블릿 매개변수, 프로퍼티 파일 등 다양한 소스를 일관된 방식으로 사용할 수 있게 지원한다.

@Value는 환경 설정정보 또는 다른 빈을 이용해 빈 프로퍼티 값을 설정한다.
 
 # 스프링 표현 언어를 이용한 빈 프로퍼티 값 설정하기
 스프링 표현 언어(줄여서 SpEL)는 런타임시에 객체 그래프를 조회하고 조작하는 스프링 전용 표현식 언어다.
 표현식을 통해 다른 빈 객체나 프로퍼티에 접근할 수도 있고, 다양한 연산도 할 수 있다.
 #{} 안에 작성된 표현식의 평가 결과를 빈 프로퍼티 값으로 설정한다.
 